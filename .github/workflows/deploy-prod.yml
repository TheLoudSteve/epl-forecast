name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:

env:
  AWS_REGION: us-west-2
  ENVIRONMENT: prod

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Package Lambda functions
      run: |
        mkdir -p lambda-packages
        
        # Package api_handler with clean build directory
        mkdir -p build/api_handler
        cp backend/api_handler.py build/api_handler/
        cd build/api_handler
        pip install -r ../../backend/requirements.txt -t .
        zip -r ../../lambda-packages/api_handler.zip .
        cd ../..
        
        # Package scheduled_data_fetcher with clean build directory
        mkdir -p build/scheduled_data_fetcher
        cp backend/scheduled_data_fetcher.py build/scheduled_data_fetcher/
        cd build/scheduled_data_fetcher
        pip install -r ../../backend/requirements.txt -t .
        pip install requests -t .
        zip -r ../../lambda-packages/scheduled_data_fetcher.zip .
        cd ../..
        
        # Package live_match_fetcher with clean build directory
        mkdir -p build/live_match_fetcher
        cp backend/live_match_fetcher.py build/live_match_fetcher/
        cd build/live_match_fetcher
        pip install -r ../../backend/requirements.txt -t .
        pip install requests icalendar -t .
        zip -r ../../lambda-packages/live_match_fetcher.zip .
        cd ../..
    
    - name: Upload Lambda packages to S3
      run: |
        # Create deployment bucket if it doesn't exist
        BUCKET_NAME="epl-forecast-prod-deployments-$(aws sts get-caller-identity --query Account --output text)"
        aws s3 mb s3://$BUCKET_NAME --region ${{ env.AWS_REGION }} 2>/dev/null || true
        
        # Upload packages
        aws s3 cp lambda-packages/api_handler.zip s3://$BUCKET_NAME/
        aws s3 cp lambda-packages/scheduled_data_fetcher.zip s3://$BUCKET_NAME/
        aws s3 cp lambda-packages/live_match_fetcher.zip s3://$BUCKET_NAME/
    
    - name: Check if stack exists and cleanup if needed
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name epl-forecast-${{ env.ENVIRONMENT }} --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_EXISTS")
        echo "Stack status: $STACK_STATUS"
        
        if [[ "$STACK_STATUS" == "ROLLBACK_COMPLETE" ]]; then
          echo "Deleting failed stack..."
          aws cloudformation delete-stack --stack-name epl-forecast-${{ env.ENVIRONMENT }}
          aws cloudformation wait stack-delete-complete --stack-name epl-forecast-${{ env.ENVIRONMENT }}
          echo "Stack deleted successfully"
        fi
    
    - name: Deploy CloudFormation stack
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        BUCKET_NAME="epl-forecast-prod-deployments-$ACCOUNT_ID"
        
        echo "Deploying CloudFormation stack..."
        set +e  # Don't exit on error
        aws cloudformation deploy \
          --template-file infrastructure/step6.yaml \
          --stack-name epl-forecast-${{ env.ENVIRONMENT }} \
          --parameter-overrides \
            Environment=${{ env.ENVIRONMENT }} \
            RapidAPIKey=${{ secrets.RAPIDAPI_KEY }} \
            S3BucketName=$BUCKET_NAME \
            NewRelicAccountId=${{ secrets.NEW_RELIC_ACCOUNT_ID }} \
            NewRelicLicenseKey=${{ secrets.NEW_RELIC_LICENSE_KEY }} \
            NewRelicIngestKey=${{ secrets.NEW_RELIC_INGEST_KEY }} \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --no-fail-on-empty-changeset
        
        DEPLOY_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
          echo "CloudFormation deployment completed successfully"
        elif [ $DEPLOY_EXIT_CODE -eq 255 ]; then
          echo "CloudFormation deployment failed"
          aws cloudformation describe-stack-events --stack-name epl-forecast-${{ env.ENVIRONMENT }} --region ${{ env.AWS_REGION }} --max-items 5 --query 'StackEvents[?ResourceStatus==`CREATE_FAILED` || ResourceStatus==`UPDATE_FAILED`].[Timestamp,ResourceType,ResourceStatus,ResourceStatusReason]' --output table
          exit 1
        else
          echo "CloudFormation deployment completed with exit code: $DEPLOY_EXIT_CODE"
        fi
    
    - name: Update Lambda function code
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        BUCKET_NAME="epl-forecast-prod-deployments-$ACCOUNT_ID"
        
        # Update API handler function
        aws lambda update-function-code \
          --function-name epl-api-handler-${{ env.ENVIRONMENT }} \
          --s3-bucket $BUCKET_NAME \
          --s3-key api_handler.zip \
          --region ${{ env.AWS_REGION }}
        
        # Update scheduled data fetcher function
        aws lambda update-function-code \
          --function-name epl-scheduled-fetcher-${{ env.ENVIRONMENT }} \
          --s3-bucket $BUCKET_NAME \
          --s3-key scheduled_data_fetcher.zip \
          --region ${{ env.AWS_REGION }}
        
        # Update live match fetcher function
        aws lambda update-function-code \
          --function-name epl-live-fetcher-${{ env.ENVIRONMENT }} \
          --s3-bucket $BUCKET_NAME \
          --s3-key live_match_fetcher.zip \
          --region ${{ env.AWS_REGION }}
    
    - name: Get API endpoint and run integration tests
      run: |
        API_ENDPOINT=$(aws cloudformation describe-stacks \
          --stack-name epl-forecast-${{ env.ENVIRONMENT }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`APIEndpoint`].OutputValue' \
          --output text)
        
        echo "Production API Endpoint: $API_ENDPOINT"
        
        if [[ -n "$API_ENDPOINT" ]]; then
          # Wait for API to be ready
          echo "Waiting 60 seconds for API to initialize..."
          sleep 60
          
          # Test health endpoint
          echo "Testing /health endpoint..."
          curl -f "$API_ENDPOINT/health" || echo "Health endpoint not yet ready"
          
          # Test table endpoint (may need time for data to populate)
          echo "Testing /table endpoint..."
          curl -f "$API_ENDPOINT/table" || echo "Table endpoint may need time to populate data"
          
          echo "Production deployment completed successfully!"
          echo "API Endpoint: $API_ENDPOINT"
        else
          echo "ERROR: Could not get API endpoint from CloudFormation output"
          exit 1
        fi