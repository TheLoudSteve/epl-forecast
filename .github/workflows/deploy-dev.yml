name: Deploy to Development

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ENVIRONMENT: dev
  STACK_NAME: epl-forecast-dev

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Validate CloudFormation template
      run: |
        echo "Validating CloudFormation template..."
        aws cloudformation validate-template \
          --template-body file://infrastructure/step6.yaml
        echo "‚úÖ Template validation passed"
    
    - name: Check template parameters
      run: |
        echo "Checking required parameters..."
        
        # Extract parameters from template
        TEMPLATE_PARAMS=$(aws cloudformation validate-template --template-body file://infrastructure/step6.yaml --query 'Parameters[].ParameterKey' --output text)
        echo "Template expects parameters: $TEMPLATE_PARAMS"
        
        # Check we have all required secrets
        MISSING_PARAMS=""
        
        if [ -z "${{ secrets.RAPIDAPI_KEY }}" ]; then
          MISSING_PARAMS="$MISSING_PARAMS RapidAPIKey"
        fi
        
        if [ -z "${{ secrets.NEW_RELIC_ACCOUNT_ID }}" ]; then
          MISSING_PARAMS="$MISSING_PARAMS NewRelicAccountId"
        fi
        
        if [ -z "${{ secrets.NEW_RELIC_LICENSE_KEY }}" ]; then
          MISSING_PARAMS="$MISSING_PARAMS NewRelicLicenseKey"
        fi
        
        if [ -z "${{ secrets.NEW_RELIC_INGEST_KEY }}" ]; then
          MISSING_PARAMS="$MISSING_PARAMS NewRelicIngestKey"
        fi
        
        if [ -n "$MISSING_PARAMS" ]; then
          echo "‚ùå Missing required parameters: $MISSING_PARAMS"
          exit 1
        fi
        
        echo "‚úÖ All required parameters available"

  test:
    needs: validate
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        pip install pytest pytest-cov "moto[all]"
    
    - name: Run tests
      run: |
        cd backend
        python -m pytest tests/ -v --cov=. --cov-report=xml || true

  deploy-infrastructure:
    needs: [validate, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      changeset-created: ${{ steps.changeset.outputs.changeset-created }}
      changeset-id: ${{ steps.changeset.outputs.changeset-id }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Check for stack drift
      run: |
        echo "Checking for stack drift..."
        
        if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} >/dev/null 2>&1; then
          echo "Stack exists, checking for drift..."
          
          # Start drift detection
          DRIFT_ID=$(aws cloudformation detect-stack-drift --stack-name ${{ env.STACK_NAME }} --query 'StackDriftDetectionId' --output text)
          
          # Wait for drift detection to complete
          echo "Waiting for drift detection to complete..."
          while true; do
            STATUS=$(aws cloudformation describe-stack-drift-detection-status --stack-drift-detection-id $DRIFT_ID --query 'DetectionStatus' --output text 2>/dev/null || echo "FAILED")
            if [ "$STATUS" = "DETECTION_COMPLETE" ]; then
              break
            elif [ "$STATUS" = "DETECTION_FAILED" ]; then
              echo "‚ùå Drift detection failed"
              exit 1
            else
              echo "Current status: $STATUS, waiting..."
              sleep 5
            fi
          done
          
          # Get drift status
          DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status --stack-drift-detection-id $DRIFT_ID --query 'StackDriftStatus' --output text)
          
          echo "Stack drift status: $DRIFT_STATUS"
          
          if [ "$DRIFT_STATUS" = "DRIFTED" ]; then
            echo "‚ö†Ô∏è  Stack has drifted from template"
            aws cloudformation describe-stack-resource-drifts --stack-name ${{ env.STACK_NAME }} --query 'StackResourceDrifts[?StackResourceDriftStatus==`MODIFIED`].[LogicalResourceId,ResourceType,StackResourceDriftStatus]' --output table
          else
            echo "‚úÖ Stack is in sync with template"
          fi
        else
          echo "Stack doesn't exist, will create new stack"
        fi

    - name: Create CloudFormation changeset
      id: changeset
      run: |
        CHANGESET_NAME="changeset-$(date +%s)"
        echo "Creating changeset: $CHANGESET_NAME"
        
        set +e  # Don't exit on error
        aws cloudformation create-change-set \
          --stack-name ${{ env.STACK_NAME }} \
          --change-set-name $CHANGESET_NAME \
          --template-body file://infrastructure/step6.yaml \
          --parameters \
            ParameterKey=Environment,ParameterValue=${{ env.ENVIRONMENT }} \
            ParameterKey=RapidAPIKey,ParameterValue=${{ secrets.RAPIDAPI_KEY }} \
            ParameterKey=NewRelicAccountId,ParameterValue=${{ secrets.NEW_RELIC_ACCOUNT_ID }} \
            ParameterKey=NewRelicLicenseKey,ParameterValue=${{ secrets.NEW_RELIC_LICENSE_KEY }} \
            ParameterKey=NewRelicIngestKey,ParameterValue=${{ secrets.NEW_RELIC_INGEST_KEY }} \
            ParameterKey=APNSCertificateArn,ParameterValue= \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --change-set-type UPDATE 2>/dev/null
        
        CHANGESET_EXIT_CODE=$?
        
        if [ $CHANGESET_EXIT_CODE -eq 0 ]; then
          echo "Changeset created successfully"
          echo "changeset-created=true" >> $GITHUB_OUTPUT
          echo "changeset-id=$CHANGESET_NAME" >> $GITHUB_OUTPUT
        else
          # Try creating stack if it doesn't exist
          echo "Trying to create new stack..."
          aws cloudformation create-change-set \
            --stack-name ${{ env.STACK_NAME }} \
            --change-set-name $CHANGESET_NAME \
            --template-body file://infrastructure/step6.yaml \
            --parameters \
              ParameterKey=Environment,ParameterValue=${{ env.ENVIRONMENT }} \
              ParameterKey=RapidAPIKey,ParameterValue=${{ secrets.RAPIDAPI_KEY }} \
              ParameterKey=NewRelicAccountId,ParameterValue=${{ secrets.NEW_RELIC_ACCOUNT_ID }} \
              ParameterKey=NewRelicLicenseKey,ParameterValue=${{ secrets.NEW_RELIC_LICENSE_KEY }} \
              ParameterKey=NewRelicIngestKey,ParameterValue=${{ secrets.NEW_RELIC_INGEST_KEY }} \
              ParameterKey=APNSCertificateArn,ParameterValue= \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --change-set-type CREATE
          
          echo "changeset-created=true" >> $GITHUB_OUTPUT
          echo "changeset-id=$CHANGESET_NAME" >> $GITHUB_OUTPUT
        fi
        
        set -e

    - name: Review changeset
      if: steps.changeset.outputs.changeset-created == 'true'
      run: |
        CHANGESET_NAME="${{ steps.changeset.outputs.changeset-id }}"
        echo "Waiting for changeset to be created..."
        
        # Wait for changeset creation
        aws cloudformation wait change-set-create-complete \
          --stack-name ${{ env.STACK_NAME }} \
          --change-set-name $CHANGESET_NAME
        
        echo "Changeset contents:"
        aws cloudformation describe-change-set \
          --stack-name ${{ env.STACK_NAME }} \
          --change-set-name $CHANGESET_NAME \
          --query 'Changes[*].[Action,ResourceChange.LogicalResourceId,ResourceChange.ResourceType,ResourceChange.Replacement]' \
          --output table
        
        # Count changes
        CHANGE_COUNT=$(aws cloudformation describe-change-set --stack-name ${{ env.STACK_NAME }} --change-set-name $CHANGESET_NAME --query 'length(Changes)' --output text)
        
        echo "Total changes: $CHANGE_COUNT"
        
        if [ "$CHANGE_COUNT" = "0" ]; then
          echo "‚ö†Ô∏è  No changes detected - this may indicate a problem"
          echo "Deleting empty changeset..."
          aws cloudformation delete-change-set --stack-name ${{ env.STACK_NAME }} --change-set-name $CHANGESET_NAME
          exit 1
        fi

    - name: Execute changeset
      if: steps.changeset.outputs.changeset-created == 'true'
      run: |
        CHANGESET_NAME="${{ steps.changeset.outputs.changeset-id }}"
        echo "Executing changeset: $CHANGESET_NAME"
        
        aws cloudformation execute-change-set \
          --stack-name ${{ env.STACK_NAME }} \
          --change-set-name $CHANGESET_NAME
        
        echo "Waiting for stack update to complete..."
        aws cloudformation wait stack-update-complete --stack-name ${{ env.STACK_NAME }}
        
        echo "‚úÖ Stack update completed successfully"

  verify-deployment:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && needs.deploy-infrastructure.outputs.changeset-created == 'true'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Verify expected resources exist
      run: |
        echo "Verifying that expected resources were created..."
        
        # Check DynamoDB tables
        echo "Checking DynamoDB tables..."
        TABLES_EXPECTED=("epl-data-dev" "epl-user-preferences-dev" "epl-forecast-history-dev")
        
        for table in "${TABLES_EXPECTED[@]}"; do
          if aws dynamodb describe-table --table-name "$table" >/dev/null 2>&1; then
            echo "‚úÖ Table $table exists"
          else
            echo "‚ùå Table $table missing"
            exit 1
          fi
        done
        
        # Check Lambda functions
        echo "Checking Lambda functions..."
        FUNCTIONS_EXPECTED=("epl-api-handler-dev" "epl-scheduled-fetcher-dev")
        
        for func in "${FUNCTIONS_EXPECTED[@]}"; do
          if aws lambda get-function --function-name "$func" >/dev/null 2>&1; then
            echo "‚úÖ Function $func exists"
          else
            echo "‚ùå Function $func missing"
            exit 1
          fi
        done
        
        # Check API Gateway
        echo "Checking API Gateway..."
        API_ID=$(aws cloudformation describe-stack-resources --stack-name ${{ env.STACK_NAME }} --logical-resource-id EPLForecastAPI --query 'StackResources[0].PhysicalResourceId' --output text)
        
        if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
          echo "‚úÖ API Gateway $API_ID exists"
          
          # Check specific API Gateway resources (preferences endpoints)
          RESOURCES=$(aws apigateway get-resources --rest-api-id "$API_ID" --query 'items[?pathPart==`preferences`].id' --output text)
          
          if [ -n "$RESOURCES" ] && [ "$RESOURCES" != "None" ]; then
            echo "‚úÖ Preferences API endpoints exist"
          else
            echo "‚ùå Preferences API endpoints missing"
            exit 1
          fi
        else
          echo "‚ùå API Gateway missing"
          exit 1
        fi
        
        echo "‚úÖ All expected resources verified"

    - name: Test API endpoints
      run: |
        # Get API endpoint
        API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].Outputs[?OutputKey==`APIEndpoint`].OutputValue' --output text)
        
        if [ -z "$API_ENDPOINT" ] || [ "$API_ENDPOINT" = "None" ]; then
          echo "‚ùå Could not get API endpoint"
          exit 1
        fi
        
        echo "Testing API endpoint: $API_ENDPOINT"
        
        # Test health endpoint
        echo "Testing /health endpoint..."
        HEALTH_RESPONSE=$(curl -s -w "%{http_code}" "$API_ENDPOINT/health")
        HTTP_CODE="${HEALTH_RESPONSE: -3}"
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úÖ Health endpoint working"
        else
          echo "‚ùå Health endpoint failed (HTTP $HTTP_CODE)"
          echo "Response: $HEALTH_RESPONSE"
          exit 1
        fi
        
        # Test preferences endpoint (should exist now)
        echo "Testing /preferences endpoint..."
        PREFS_RESPONSE=$(curl -s -w "%{http_code}" -H "X-User-ID: test" "$API_ENDPOINT/preferences")
        HTTP_CODE="${PREFS_RESPONSE: -3}"
        
        if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "400" ]; then
          echo "‚úÖ Preferences endpoint exists (HTTP $HTTP_CODE)"
        else
          echo "‚ùå Preferences endpoint failed (HTTP $HTTP_CODE)"
          echo "Response: $PREFS_RESPONSE"
          # Don't fail deployment for this - preferences might need user setup
        fi
        
        echo "‚úÖ API verification completed"

  deploy-lambda:
    needs: verify-deployment
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Package Lambda functions
      run: |
        cd backend
        pip install -r requirements.txt -t .
        
        # Package scheduled data fetcher
        zip -r scheduled_data_fetcher.zip \
          scheduled_data_fetcher.py \
          models.py \
          forecast_history.py \
          notification_logic.py \
          notification_content_generator.py \
          notification_rate_limiter.py \
          push_notification_service.py \
          boto3* requests* dateutil* six* urllib3* botocore* jmespath* s3transfer* \
          certifi* charset_normalizer* idna* newrelic* icalendar*
        
        # Package API handler
        zip -r api_handler.zip \
          api_handler.py \
          models.py \
          notification_logic.py \
          notification_content_generator.py \
          notification_rate_limiter.py \
          push_notification_service.py \
          forecast_history.py \
          boto3* botocore* jmespath* s3transfer* urllib3* certifi* dateutil* six*
    
    - name: Update Lambda functions
      run: |
        cd backend
        
        echo "Updating scheduled data fetcher..."
        aws lambda update-function-code \
          --function-name epl-scheduled-fetcher-${{ env.ENVIRONMENT }} \
          --zip-file fileb://scheduled_data_fetcher.zip
        
        echo "Updating API handler..."
        aws lambda update-function-code \
          --function-name epl-api-handler-${{ env.ENVIRONMENT }} \
          --zip-file fileb://api_handler.zip
        
        echo "‚úÖ Lambda functions updated"

    - name: Verify Lambda deployment
      run: |
        echo "Verifying Lambda function deployment..."
        
        # Test scheduled fetcher
        echo "Testing scheduled data fetcher..."
        aws lambda invoke \
          --function-name epl-scheduled-fetcher-${{ env.ENVIRONMENT }} \
          --payload '{}' \
          /tmp/scheduled_response.json
        
        if grep -q "statusCode.*200" /tmp/scheduled_response.json; then
          echo "‚úÖ Scheduled data fetcher working"
        else
          echo "‚ùå Scheduled data fetcher failed"
          cat /tmp/scheduled_response.json
          exit 1
        fi
        
        # Test API handler
        echo "Testing API handler..."
        aws lambda invoke \
          --function-name epl-api-handler-${{ env.ENVIRONMENT }} \
          --payload '{"httpMethod": "GET", "path": "/health"}' \
          /tmp/api_response.json
        
        if grep -q "statusCode.*200" /tmp/api_response.json; then
          echo "‚úÖ API handler working"
        else
          echo "‚ùå API handler failed"
          cat /tmp/api_response.json
          exit 1
        fi
        
        echo "‚úÖ Lambda verification completed"

    - name: Final integration test
      run: |
        # Get API endpoint
        API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].Outputs[?OutputKey==`APIEndpoint`].OutputValue' --output text)
        
        echo "Running final integration test on $API_ENDPOINT"
        
        # Wait for API to be fully ready
        sleep 10
        
        # Test full stack
        curl -f "$API_ENDPOINT/health" || exit 1
        curl -f "$API_ENDPOINT/table" || exit 1
        
        echo "üéâ Deployment successful and verified!"
        echo "API Endpoint: $API_ENDPOINT"