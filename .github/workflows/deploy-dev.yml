name: Deploy to Development

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ENVIRONMENT: dev

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        pip install pytest pytest-cov "moto[all]"
    
    - name: Run tests
      run: |
        cd backend
        python -m pytest tests/ -v --cov=. --cov-report=xml || true
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./backend/coverage.xml

  deploy-infrastructure:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Check and clean up failed stack
      run: |
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name epl-forecast-${{ env.ENVIRONMENT }} \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "DOES_NOT_EXIST")
        
        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "CREATE_FAILED" ]; then
          echo "Stack is in failed state ($STACK_STATUS), deleting it..."
          aws cloudformation delete-stack --stack-name epl-forecast-${{ env.ENVIRONMENT }}
          aws cloudformation wait stack-delete-complete --stack-name epl-forecast-${{ env.ENVIRONMENT }}
          echo "Stack deleted successfully"
        else
          echo "Stack status: $STACK_STATUS"
        fi

    - name: Deploy CloudFormation stack
      run: |
        echo "Deploying CloudFormation stack..."
        echo "Template exists: $(test -f infrastructure/step6.yaml && echo 'YES' || echo 'NO')"
        echo "AWS CLI version: $(aws --version)"
        echo "Current region: ${{ env.AWS_REGION }}"
        echo "Environment: ${{ env.ENVIRONMENT }}"
        
        # Test AWS credentials
        aws sts get-caller-identity
        
        # Check if secrets are available
        echo "RapidAPI Key length: ${#RAPIDAPI_KEY}"
        echo "NewRelic Account ID: ${{ secrets.NEW_RELIC_ACCOUNT_ID }}"
        echo "NewRelic License Key length: ${#NEW_RELIC_LICENSE_KEY}"
        echo "NewRelic Ingest Key length: ${#NEW_RELIC_INGEST_KEY}"
        
        set +e  # Don't exit on error
        timeout 600 aws cloudformation deploy \
          --template-file infrastructure/step6.yaml \
          --stack-name epl-forecast-${{ env.ENVIRONMENT }} \
          --parameter-overrides \
            "Environment=${{ env.ENVIRONMENT }}" \
            "RapidAPIKey=${{ secrets.RAPIDAPI_KEY }}" \
            "NewRelicAccountId=${{ secrets.NEW_RELIC_ACCOUNT_ID }}" \
            "NewRelicLicenseKey=${{ secrets.NEW_RELIC_LICENSE_KEY }}" \
            "NewRelicIngestKey=${{ secrets.NEW_RELIC_INGEST_KEY }}" \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --no-fail-on-empty-changeset
        
        DEPLOY_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
          echo "CloudFormation deployment completed successfully"
        elif [ $DEPLOY_EXIT_CODE -eq 124 ]; then
          echo "CloudFormation deployment timed out after 10 minutes"
          exit 1
        elif [ $DEPLOY_EXIT_CODE -eq 255 ]; then
          echo "CloudFormation deployment failed"
          aws cloudformation describe-stack-events --stack-name epl-forecast-${{ env.ENVIRONMENT }} --region ${{ env.AWS_REGION }} --max-items 10 --query 'StackEvents[*].[Timestamp,ResourceType,ResourceStatus,ResourceStatusReason]' --output table
          exit 1
        else
          echo "CloudFormation deployment completed with exit code: $DEPLOY_EXIT_CODE"
        fi
      env:
        RAPIDAPI_KEY: ${{ secrets.RAPIDAPI_KEY }}
        NEW_RELIC_LICENSE_KEY: ${{ secrets.NEW_RELIC_LICENSE_KEY }}
        NEW_RELIC_INGEST_KEY: ${{ secrets.NEW_RELIC_INGEST_KEY }}

  deploy-lambda:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Package Lambda functions
      run: |
        cd backend
        pip install -r requirements.txt -t .
        zip -r scheduled_data_fetcher.zip scheduled_data_fetcher.py models.py forecast_history.py notification_logic.py notification_content_generator.py notification_rate_limiter.py push_notification_service.py boto3* requests* dateutil* six* urllib3* botocore* jmespath* s3transfer* certifi* charset_normalizer* idna* newrelic* icalendar*
        zip -r api_handler.zip api_handler.py models.py notification_logic.py notification_content_generator.py notification_rate_limiter.py push_notification_service.py forecast_history.py boto3* botocore* jmespath* s3transfer* urllib3* certifi* dateutil* six*
    
    - name: Update Lambda functions
      run: |
        cd backend
        aws lambda update-function-code \
          --function-name epl-scheduled-fetcher-${{ env.ENVIRONMENT }} \
          --zip-file fileb://scheduled_data_fetcher.zip
        
        aws lambda update-function-code \
          --function-name epl-api-handler-${{ env.ENVIRONMENT }} \
          --zip-file fileb://api_handler.zip
    
    - name: Get API endpoint
      run: |
        API_ENDPOINT=$(aws cloudformation describe-stacks \
          --stack-name epl-forecast-${{ env.ENVIRONMENT }} \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`APIEndpoint`].OutputValue' \
          --output text)
        echo "API Endpoint: $API_ENDPOINT"
        echo "API_ENDPOINT=$API_ENDPOINT" >> $GITHUB_ENV
    
    - name: Trigger initial data fetch
      run: |
        aws lambda invoke \
          --function-name epl-scheduled-fetcher-${{ env.ENVIRONMENT }} \
          --region ${{ env.AWS_REGION }} \
          --payload '{}' \
          response.json
        echo "Scheduled data fetcher response:"
        cat response.json