name: Deploy to Development

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION_DEV }}
  ENVIRONMENT: dev
  STACK_NAME: epl-forecast-dev-usw2

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Validate CloudFormation template
      run: |
        echo "Validating CloudFormation template..."
        aws cloudformation validate-template \
          --template-body file://infrastructure/step6.yaml
        echo "‚úÖ Template validation passed"
    
    - name: Check template parameters
      run: |
        echo "Checking required parameters..."
        
        # Extract parameters from template
        TEMPLATE_PARAMS=$(aws cloudformation validate-template --template-body file://infrastructure/step6.yaml --query 'Parameters[].ParameterKey' --output text)
        echo "Template expects parameters: $TEMPLATE_PARAMS"
        
        # Check we have all required secrets
        MISSING_PARAMS=""
        
        if [ -z "${{ secrets.RAPIDAPI_KEY }}" ]; then
          MISSING_PARAMS="$MISSING_PARAMS RapidAPIKey"
        fi
        
        if [ -z "${{ secrets.NEW_RELIC_ACCOUNT_ID }}" ]; then
          MISSING_PARAMS="$MISSING_PARAMS NewRelicAccountId"
        fi
        
        if [ -z "${{ secrets.NEW_RELIC_LICENSE_KEY }}" ]; then
          MISSING_PARAMS="$MISSING_PARAMS NewRelicLicenseKey"
        fi
        
        
        if [ -n "$MISSING_PARAMS" ]; then
          echo "‚ùå Missing required parameters: $MISSING_PARAMS"
          exit 1
        fi
        
        echo "‚úÖ All required parameters available"

  test:
    needs: validate
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        pip install pytest pytest-cov "moto[all]"
    
    - name: Run tests
      run: |
        cd backend
        python -m pytest tests/ -v --cov=. --cov-report=xml || true

  deploy-infrastructure:
    needs: [validate, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      changeset-created: ${{ steps.changeset.outputs.changeset-created }}
      changeset-id: ${{ steps.changeset.outputs.changeset-id }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Check stack status
      run: |
        echo "Checking stack status..."
        
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_EXISTS")
        echo "Stack status: $STACK_STATUS"
        
        if [ "$STACK_STATUS" != "NOT_EXISTS" ] && [ "$STACK_STATUS" != "DELETE_COMPLETE" ] && [ "$STACK_STATUS" != "ROLLBACK_COMPLETE" ]; then
          echo "‚úÖ Stack exists - will attempt UPDATE changeset"
        else
          echo "‚úÖ Stack doesn't exist - will attempt CREATE changeset"
        fi

    - name: Create CloudFormation changeset
      id: changeset
      run: |
        CHANGESET_NAME="changeset-$(date +%s)"
        echo "Creating changeset: $CHANGESET_NAME"
        
        set +e  # Don't exit on error
        aws cloudformation create-change-set \
          --stack-name ${{ env.STACK_NAME }} \
          --change-set-name $CHANGESET_NAME \
          --template-body file://infrastructure/step6.yaml \
          --parameters \
            ParameterKey=Environment,ParameterValue=${{ env.ENVIRONMENT }} \
            ParameterKey=RapidAPIKey,ParameterValue=${{ secrets.RAPIDAPI_KEY }} \
            ParameterKey=NewRelicAccountId,ParameterValue=${{ secrets.NEW_RELIC_ACCOUNT_ID }} \
            ParameterKey=NewRelicLicenseKey,ParameterValue=${{ secrets.NEW_RELIC_LICENSE_KEY }} \
            ParameterKey=APNSPlatformApplicationArn,ParameterValue= \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --change-set-type UPDATE 2>/dev/null
        
        CHANGESET_EXIT_CODE=$?
        
        if [ $CHANGESET_EXIT_CODE -eq 0 ]; then
          echo "Changeset created successfully"
          echo "changeset-created=true" >> $GITHUB_OUTPUT
          echo "changeset-id=$CHANGESET_NAME" >> $GITHUB_OUTPUT
        else
          # Try creating stack if it doesn't exist
          echo "Trying to create new stack..."
          if aws cloudformation create-change-set \
            --stack-name ${{ env.STACK_NAME }} \
            --change-set-name $CHANGESET_NAME \
            --template-body file://infrastructure/step6.yaml \
            --parameters \
              ParameterKey=Environment,ParameterValue=${{ env.ENVIRONMENT }} \
              ParameterKey=RapidAPIKey,ParameterValue=${{ secrets.RAPIDAPI_KEY }} \
              ParameterKey=NewRelicAccountId,ParameterValue=${{ secrets.NEW_RELIC_ACCOUNT_ID }} \
              ParameterKey=NewRelicLicenseKey,ParameterValue=${{ secrets.NEW_RELIC_LICENSE_KEY }} \
              ParameterKey=APNSPlatformApplicationArn,ParameterValue= \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --change-set-type CREATE; then
            
            echo "Create changeset succeeded"
            echo "changeset-created=true" >> $GITHUB_OUTPUT
            echo "changeset-id=$CHANGESET_NAME" >> $GITHUB_OUTPUT
          else
            echo "Both UPDATE and CREATE changeset creation failed"
            echo "Attempting to capture changeset failure reason..."
            
            # Try to find any failed changesets
            aws cloudformation list-change-sets --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} || true
            
            # Try to get stack events for more details
            echo "Stack events:"
            aws cloudformation describe-stack-events --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} --max-items 5 --query 'StackEvents[*].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]' --output table || true
            
            echo "changeset-created=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        fi
        
        set -e

    - name: Review changeset
      id: review-changeset
      if: steps.changeset.outputs.changeset-created == 'true'
      run: |
        CHANGESET_NAME="${{ steps.changeset.outputs.changeset-id }}"
        echo "Checking changeset status..."
        
        # Wait a moment for changeset to be processed
        sleep 5
        
        # Check changeset status - handle both success and no-changes failure
        CHANGESET_STATUS=$(aws cloudformation describe-change-set --stack-name ${{ env.STACK_NAME }} --change-set-name $CHANGESET_NAME --query 'Status' --output text 2>/dev/null || echo "NOT_FOUND")
        echo "Changeset status: $CHANGESET_STATUS"
        
        if [ "$CHANGESET_STATUS" = "CREATE_COMPLETE" ]; then
          echo "Changeset created successfully"
          
          echo "Changeset contents:"
          aws cloudformation describe-change-set \
            --stack-name ${{ env.STACK_NAME }} \
            --change-set-name $CHANGESET_NAME \
            --query 'Changes[*].[Action,ResourceChange.LogicalResourceId,ResourceChange.ResourceType,ResourceChange.Replacement]' \
            --output table
          
          # Count changes
          CHANGE_COUNT=$(aws cloudformation describe-change-set --stack-name ${{ env.STACK_NAME }} --change-set-name $CHANGESET_NAME --query 'length(Changes)' --output text)
        elif [ "$CHANGESET_STATUS" = "FAILED" ]; then
          # Check if failure is due to no changes
          STATUS_REASON=$(aws cloudformation describe-change-set --stack-name ${{ env.STACK_NAME }} --change-set-name $CHANGESET_NAME --query 'StatusReason' --output text 2>/dev/null || echo "")
          echo "Changeset failure reason: $STATUS_REASON"
          
          if [[ "$STATUS_REASON" == *"didn't contain changes"* ]] || [[ "$STATUS_REASON" == *"no changes"* ]]; then
            echo "‚úÖ No changes needed - stack is already up-to-date"
            CHANGE_COUNT="0"
          else
            echo "‚ùå Changeset failed for other reason: $STATUS_REASON"
            exit 1
          fi
        else
          echo "‚ùå Unexpected changeset status: $CHANGESET_STATUS"
          exit 1
        fi
        
        echo "Total changes: $CHANGE_COUNT"
        
        if [ "$CHANGE_COUNT" = "0" ]; then
          echo "‚úÖ No changes needed - stack is already up-to-date"
          echo "Deleting empty changeset..."
          aws cloudformation delete-change-set --stack-name ${{ env.STACK_NAME }} --change-set-name $CHANGESET_NAME
          echo "changeset-needs-execution=false" >> $GITHUB_OUTPUT
          echo "stack-already-updated=true" >> $GITHUB_OUTPUT
        else
          echo "Changes to be applied: $CHANGE_COUNT"
          echo "changeset-needs-execution=true" >> $GITHUB_OUTPUT
        fi

    - name: Execute changeset
      if: steps.changeset.outputs.changeset-created == 'true' && steps.review-changeset.outputs.changeset-needs-execution == 'true'
      run: |
        CHANGESET_NAME="${{ steps.changeset.outputs.changeset-id }}"
        echo "Executing changeset: $CHANGESET_NAME"
        
        aws cloudformation execute-change-set \
          --stack-name ${{ env.STACK_NAME }} \
          --change-set-name $CHANGESET_NAME
        
        echo "Waiting for stack operation to complete (max 20 minutes)..."
        
        # Check if this is a create or update operation
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$STACK_STATUS" == "CREATE_IN_PROGRESS" ]]; then
          echo "Stack creation in progress..."
          timeout 1200 aws cloudformation wait stack-create-complete --stack-name ${{ env.STACK_NAME }}
        else
          echo "Stack update in progress..."
          timeout 1200 aws cloudformation wait stack-update-complete --stack-name ${{ env.STACK_NAME }}
        fi
        
        echo "‚úÖ Stack update completed successfully"

    - name: Deploy API Gateway changes
      run: |
        echo "Deploying API Gateway changes to ensure endpoints are available..."
        
        # Get the API Gateway ID from CloudFormation
        API_ID=$(aws cloudformation describe-stack-resources \
          --stack-name ${{ env.STACK_NAME }} \
          --logical-resource-id EPLForecastAPI \
          --query 'StackResources[0].PhysicalResourceId' \
          --output text)
        
        if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
          echo "Creating new API Gateway deployment for API: $API_ID"
          
          aws apigateway create-deployment \
            --rest-api-id "$API_ID" \
            --stage-name ${{ env.ENVIRONMENT }} \
            --stage-description "Deployed via GitHub Actions - $(date)"
          
          echo "‚úÖ API Gateway deployed successfully"
        else
          echo "‚ùå Could not find API Gateway ID"
          exit 1
        fi

  verify-deployment:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Verify expected resources exist
      run: |
        echo "Verifying that expected resources were created..."
        
        # Check DynamoDB tables
        echo "Checking DynamoDB tables..."
        TABLES_EXPECTED=("epl-data-dev" "epl-user-preferences-dev" "epl-forecast-history-dev")
        
        for table in "${TABLES_EXPECTED[@]}"; do
          if aws dynamodb describe-table --table-name "$table" >/dev/null 2>&1; then
            echo "‚úÖ Table $table exists"
          else
            echo "‚ùå Table $table missing"
            exit 1
          fi
        done
        
        # Check Lambda functions
        echo "Checking Lambda functions..."
        FUNCTIONS_EXPECTED=("epl-api-handler-dev" "epl-scheduled-fetcher-dev")
        
        for func in "${FUNCTIONS_EXPECTED[@]}"; do
          if aws lambda get-function --function-name "$func" >/dev/null 2>&1; then
            echo "‚úÖ Function $func exists"
          else
            echo "‚ùå Function $func missing"
            exit 1
          fi
        done
        
        # Check API Gateway
        echo "Checking API Gateway..."
        API_ID=$(aws cloudformation describe-stack-resources --stack-name ${{ env.STACK_NAME }} --logical-resource-id EPLForecastAPI --query 'StackResources[0].PhysicalResourceId' --output text)
        
        if [ "$API_ID" != "None" ] && [ -n "$API_ID" ]; then
          echo "‚úÖ API Gateway $API_ID exists"
          
          # Check specific API Gateway resources (preferences endpoints)
          RESOURCES=$(aws apigateway get-resources --rest-api-id "$API_ID" --query 'items[?pathPart==`preferences`].id' --output text)
          
          if [ -n "$RESOURCES" ] && [ "$RESOURCES" != "None" ]; then
            echo "‚úÖ Preferences API endpoints exist"
          else
            echo "‚ùå Preferences API endpoints missing"
            exit 1
          fi
        else
          echo "‚ùå API Gateway missing"
          exit 1
        fi
        
        echo "‚úÖ All expected resources verified"

    - name: Test API endpoints
      run: |
        # Get API endpoint
        API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].Outputs[?OutputKey==`APIEndpoint`].OutputValue' --output text)
        
        if [ -z "$API_ENDPOINT" ] || [ "$API_ENDPOINT" = "None" ]; then
          echo "‚ùå Could not get API endpoint"
          exit 1
        fi
        
        echo "Testing API endpoint: $API_ENDPOINT"
        
        # Test health endpoint
        echo "Testing /health endpoint..."
        HEALTH_RESPONSE=$(curl -s -w "%{http_code}" "$API_ENDPOINT/health")
        HTTP_CODE="${HEALTH_RESPONSE: -3}"
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úÖ Health endpoint working"
        else
          echo "‚ùå Health endpoint failed (HTTP $HTTP_CODE)"
          echo "Response: $HEALTH_RESPONSE"
          exit 1
        fi
        
        # Test preferences endpoint (should exist now)
        echo "Testing /preferences endpoint..."
        PREFS_RESPONSE=$(curl -s -w "%{http_code}" -H "X-User-ID: test" "$API_ENDPOINT/preferences")
        HTTP_CODE="${PREFS_RESPONSE: -3}"
        
        if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "400" ]; then
          echo "‚úÖ Preferences endpoint exists (HTTP $HTTP_CODE)"
        else
          echo "‚ùå Preferences endpoint failed (HTTP $HTTP_CODE)"
          echo "Response: $PREFS_RESPONSE"
          # Don't fail deployment for this - preferences might need user setup
        fi
        
        echo "‚úÖ API verification completed"

  deploy-lambda:
    needs: verify-deployment
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Package Lambda functions
      run: |
        cd backend
        pip install -r requirements.txt -t .
        
        # Package scheduled data fetcher
        zip -r scheduled_data_fetcher.zip \
          scheduled_data_fetcher.py \
          models.py \
          forecast_history.py \
          notification_logic.py \
          notification_content_generator.py \
          notification_rate_limiter.py \
          push_notification_service.py \
          boto3* requests* dateutil* six* urllib3* botocore* jmespath* s3transfer* \
          certifi* charset_normalizer* idna* newrelic* icalendar*
        
        # Package API handler
        zip -r api_handler.zip \
          api_handler.py \
          models.py \
          notification_logic.py \
          notification_content_generator.py \
          notification_rate_limiter.py \
          push_notification_service.py \
          forecast_history.py \
          boto3* botocore* jmespath* s3transfer* urllib3* certifi* dateutil* six*
    
    - name: Update Lambda functions
      run: |
        cd backend
        
        echo "Updating scheduled data fetcher..."
        aws lambda update-function-code \
          --function-name epl-scheduled-fetcher-${{ env.ENVIRONMENT }} \
          --zip-file fileb://scheduled_data_fetcher.zip
        
        echo "Updating API handler..."
        aws lambda update-function-code \
          --function-name epl-api-handler-${{ env.ENVIRONMENT }} \
          --zip-file fileb://api_handler.zip
        
        echo "‚úÖ Lambda functions updated"

    - name: Verify Lambda deployment
      run: |
        echo "Verifying Lambda function deployment..."
        
        # Test scheduled fetcher
        echo "Testing scheduled data fetcher..."
        aws lambda invoke \
          --function-name epl-scheduled-fetcher-${{ env.ENVIRONMENT }} \
          --payload '{}' \
          /tmp/scheduled_response.json
        
        if grep -q "statusCode.*200" /tmp/scheduled_response.json; then
          echo "‚úÖ Scheduled data fetcher working"
        else
          echo "‚ùå Scheduled data fetcher failed"
          cat /tmp/scheduled_response.json
          exit 1
        fi
        
        # Test API handler
        echo "Testing API handler..."
        aws lambda invoke \
          --function-name epl-api-handler-${{ env.ENVIRONMENT }} \
          --payload '{"httpMethod": "GET", "path": "/health"}' \
          /tmp/api_response.json
        
        if grep -q "statusCode.*200" /tmp/api_response.json; then
          echo "‚úÖ API handler working"
        else
          echo "‚ùå API handler failed"
          cat /tmp/api_response.json
          exit 1
        fi
        
        echo "‚úÖ Lambda verification completed"

    - name: Final integration test
      run: |
        # Get API endpoint
        API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query 'Stacks[0].Outputs[?OutputKey==`APIEndpoint`].OutputValue' --output text)
        
        echo "Running final integration test on $API_ENDPOINT"
        
        # Wait for API to be fully ready
        sleep 10
        
        # Test full stack
        curl -f "$API_ENDPOINT/health" || exit 1
        curl -f "$API_ENDPOINT/table" || exit 1
        
        echo "üéâ Deployment successful and verified!"
        echo "API Endpoint: $API_ENDPOINT"